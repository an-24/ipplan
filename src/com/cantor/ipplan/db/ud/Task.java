package com.cantor.ipplan.db.ud;

// Generated 24.06.2013 9:21:29 by Hibernate Tools 3.4.0.CR1

import java.util.Date;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

import org.hibernate.Hibernate;

import com.cantor.ipplan.core.DataBridge;
import com.cantor.ipplan.shared.TaskWrapper;

/**
 * Task generated by hbm2java
 */
@SuppressWarnings("serial")
@Entity
@Table(name = "TASK")
public class Task implements java.io.Serializable,DataBridge<TaskWrapper> {

	private int taskId;
	private Status afterStatus;
	private Tasktype tasktype;
	private Calendar calendar;
	private String taskName;
	private Date taskDeadline;
	private Date taskStart;
	private Integer taskWarningDuration;
	private Integer taskWarningUnit;
	private String taskPlace;
	private int taskExecuted = 0;
	private Date taskLastupdate;
	

	public Task() {
	}

	public Task(int taskId, Tasktype tasktype, Calendar calendar,
			String taskName, Date taskDeadline) {
		this.taskId = taskId;
		this.tasktype = tasktype;
		this.calendar = calendar;
		this.taskName = taskName;
		this.taskDeadline = taskDeadline;
	}

	public Task(int taskId, Status status, Tasktype tasktype,
			Calendar calendar, String taskName, Date taskDeadline,
			Date taskStart, Integer taskWarningDuration,
			Integer taskWarningUnit, String taskPlace) {
		this.taskId = taskId;
		this.afterStatus = status;
		this.tasktype = tasktype;
		this.calendar = calendar;
		this.taskName = taskName;
		this.taskDeadline = taskDeadline;
		this.taskStart = taskStart;
		this.taskWarningDuration = taskWarningDuration;
		this.taskWarningUnit = taskWarningUnit;
		this.taskPlace = taskPlace;
	}

	@Id
	@javax.persistence.SequenceGenerator(name="newRec", sequenceName="NEWRECORDID")	
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "newRec")
	@Column(name = "TASK_ID", unique = true, nullable = false)
	public int getTaskId() {
		return this.taskId;
	}

	public void setTaskId(int taskId) {
		this.taskId = taskId;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "AFTER_STATUS_ID")
	public Status getStatus() {
		return this.afterStatus;
	}

	public void setStatus(Status status) {
		this.afterStatus = status;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "TASKTYPE_ID", nullable = false)
	public Tasktype getTasktype() {
		return this.tasktype;
	}

	public void setTasktype(Tasktype tasktype) {
		this.tasktype = tasktype;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "BARGAIN_ID", nullable = false)
	public Calendar getCalendar() {
		return this.calendar;
	}

	public void setCalendar(Calendar calendar) {
		this.calendar = calendar;
	}

	@Column(name = "TASK_NAME", nullable = false, length = 240)
	public String getTaskName() {
		return this.taskName;
	}

	public void setTaskName(String taskName) {
		this.taskName = taskName;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "TASK_DEADLINE", nullable = false, length = 19)
	public Date getTaskDeadline() {
		return this.taskDeadline;
	}

	public void setTaskDeadline(Date taskDeadline) {
		this.taskDeadline = taskDeadline;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "TASK_START", length = 19)
	public Date getTaskStart() {
		return this.taskStart;
	}

	public void setTaskStart(Date taskStart) {
		this.taskStart = taskStart;
	}

	@Column(name = "TASK_WARNING_DURATION")
	public Integer getTaskWarningDuration() {
		return this.taskWarningDuration;
	}

	public void setTaskWarningDuration(Integer taskWarningDuration) {
		this.taskWarningDuration = taskWarningDuration;
	}

	@Column(name = "TASK_WARNING_UNIT")
	public Integer getTaskWarningUnit() {
		return this.taskWarningUnit;
	}

	public void setTaskWarningUnit(Integer taskWarningUnit) {
		this.taskWarningUnit = taskWarningUnit;
	}

	@Column(name = "TASK_PLACE", length = 200)
	public String getTaskPlace() {
		return this.taskPlace;
	}

	public void setTaskPlace(String taskPlace) {
		this.taskPlace = taskPlace;
	}

	@Column(name = "TASK_EXECUTED", nullable = false)
	public int getTaskExecuted() {
		return taskExecuted;
	}

	public void setTaskExecuted(int taskExecuted) {
		this.taskExecuted = taskExecuted;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "TASK_LASTUPDATE", nullable = true, length = 19)
	public Date getTaskLastupdate() {
		return taskLastupdate;
	}

	public void setTaskLastupdate(Date taskLastupdate) {
		this.taskLastupdate = taskLastupdate;
	}

	@Override
	public TaskWrapper toClient() {
		TaskWrapper wrap = new TaskWrapper();
		wrap.taskId = taskId;
		if(afterStatus!=null) wrap.afterStatus = afterStatus.toClient();
		wrap.tasktype = tasktype.toClient();
		wrap.calendar = calendar.toClient();
		wrap.taskName = taskName;
		wrap.taskDeadline = taskDeadline;
		wrap.taskStart = taskStart;
		wrap.taskWarningDuration = taskWarningDuration;
		wrap.taskWarningUnit = taskWarningUnit;
		wrap.taskPlace = taskPlace;
		wrap.taskExecuted = taskExecuted;
		return wrap;
	}

	@Override
	public void fromClient(TaskWrapper data) {
		taskId = data.taskId;
		if(data.afterStatus!=null) {
			afterStatus = new Status();
			afterStatus.fromClient(data.afterStatus);
		}
		if(data.tasktype!=null) {
			tasktype = new Tasktype();
			tasktype.fromClient(data.tasktype);
		}
		if(data.calendar!= null) {
			calendar = new Calendar();
			calendar.fromClient(data.calendar);
		}
		taskName = data.taskName;
		taskDeadline = data.taskDeadline;
		taskStart = data.taskStart;
		taskWarningDuration = data.taskWarningDuration;
		taskWarningUnit = data.taskWarningUnit;
		taskPlace = data.taskPlace;
		taskExecuted = data.taskExecuted;
	}

	@Override
	public void fetch(boolean deep) {
		if(afterStatus!=null) Hibernate.initialize(afterStatus);
		Hibernate.initialize(tasktype);
		Hibernate.initialize(calendar);
		if(deep) {
			if(getStatus()!=null) getStatus().fetch(deep);
			getTasktype().fetch(deep);
			getCalendar().fetch(deep);
		}
	}



}
